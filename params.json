{"tagline":"Another dynamically-typed, lightweight programming language","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"## Luci\r\n\r\nLuci is a procedural, dynamically-typed toy scripting language, implemented in C.\r\n\r\nLuci's syntax resembles C and is still a work in progress.\r\n\r\nThe implementation is slowly evolving into a bytecode-compiled,\r\nvirtual machine interpreter model. Its initial form consisted of\r\nan abstract syntax tree and a series of functions which walked the\r\ntree and 'executed' each node.\r\n\r\n\r\n### Syntax\r\n\r\nLuci's syntax heavily resembles that of the language C.\r\n\r\n\r\n### Tools Needed to Build\r\n\r\n- [flex (lex)](http://flex.sourceforge.net/)\r\n- [bison (yacc)](http://www.gnu.org/software/bison/)\r\n- a decent C compiler (gcc)\r\n\r\n\r\n### References\r\n\r\n- [Immensely helpful](http://stackoverflow.com/a/2644949)\r\n- [Just as useful](http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/)\r\n- [One of my questions](http://stackoverflow.com/q/13094001/1689220)\r\n- [Implementation of Lua (PDF)](http://www.lua.org/doc/jucs05.pdf)\r\n- [Interpreter implementation options](http://realityforge.org/code/virtual-machines/2011/05/19/interpreters.html)\r\n- [Python's Innards](http://tech.blog.aknin.name/2010/04/02/pythons-innards-introduction/)\r\n\r\n\r\n### TODO (version 0.2)\r\n\r\n- Add support for both empty strings and escape characters\r\n- Track symbol names throughout compilation (useful when printing bytecode)\r\n- Implement interactive mode (like Python's `>>>`)\r\n- Serialize bytecode/symbols/constants (like Python's .pyc files)\r\n- Finalize syntax\r\n- Implement bytecode compiler\r\n\r\n  - Determine/iteratively improve instruction set\r\n  - Append instructions faster (currently function call for each)\r\n  - Backpatch instructions faster (currently function call for each)\r\n  - Cleanly store loop state for backpatching `BREAK` and `CONTINUE`\r\n  - Implement efficient symbol table (hash)\r\n  - Implement useful constant table (hash constants... currently storing duplicates)\r\n  - Design function prototypes\r\n  - Bytecode optimizations\r\n\r\n- Implement bytecode interpreter (VM)\r\n\r\n  - Efficient object stack\r\n  - Fast instruction dispatch (gcc *computed goto* vs. *switch-case*)\r\n  - Proper function call/return handling (call stack)\r\n\r\n- Implement a memory manager optimized for allocating many small blocks.\r\n  This heavily relies on a permanent design decision for Luci's\r\n  types (objects) implementation (Fixed-size (union) or variable (Python)).\r\n\r\n- Potentially integrate a garbage collector in the memory manager.\r\n  This would eliminate the need to store reference counts for each\r\n  object.\r\n\r\n- Possibly implement an API for creating libraries\r\n\r\n\r\n### Completed in version 0.1\r\n\r\nThe following features were completed in Luci v0.1.\r\nLuci v0.1 simply walked the abstract syntax tree and,\r\nfor each node, executed analogous expressions in C, i.e.\r\nfor each *if-else* node, a C function in the AST walking\r\ncode would recursively evaluate the conditional expression,\r\nthen if it was `true`, evaluate the *if-statements* node,\r\notherwise it would evaluate the *else-statements* node.\r\n\r\nThis version is now obsolete, as the implementation\r\nwas inefficient and did not allow for nested control flow\r\nstatements, i.e. `break`, `continue`, `return`.\r\n\r\n1. Implement all unary/binary operations offered by the C++ standard\r\n   (with proper operator precedence for each)\r\n2. Implement Integer, Double, and String types\r\n3. Implement a While loop construct\r\n4. Implement error recover (made a single exit point `die()`), which has global\r\n   access to the root ASTNode and root ExecEnviron\r\n5. Implement if/else conditional blocks. Decided against 'else if', which simplifies parser.\r\n6. Implement multi-parameter functions\r\n7. Implement a FILE * luci type, with open(), close(), read(), write() functions\r\n8. Create list types (syntax/parse), rename 'parameter' AST nodes since they're lists\r\n9. Implement For loops\r\n10. Re-work allocation/deallocation of LuciObjects to incorporate\r\n    reference counts.\r\n11. Rewrite list implementation to use dynamic array of pointers (rather than singly-linked\r\n    list. The singly-linked list was far less convenient since I'm using lists to implement\r\n    function parameters.\r\n12. Implement user-defined functions (barely)\r\n13. Track line numbers in abstract syntax tree for more helpful Runtime Error messages.\r\n","name":"Luci"}