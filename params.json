{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Luci","tagline":"Another dynamically-typed, lightweight programming language","google":"","body":"******\r\nLuci\r\n******\r\n\r\nLuci is a procedural, dynamically-typed toy scripting language, implemented in C.\r\n\r\nLuci's syntax resembles C and is still a work in progress.\r\n\r\nThe implementation is slowly evolving into a bytecode-compiled,\r\nvirtual machine interpreter model. Its initial form consisted of\r\nan abstract syntax tree and a series of functions which walked the\r\ntree and 'executed' each node.\r\n\r\nTools Needed to Build\r\n=======================\r\n\r\n- `flex (lex)`_\r\n- `bison (yacc)`_\r\n- a decent C compiler (gcc)\r\n\r\n.. _flex (lex): http://flex.sourceforge.net/\r\n.. _bison (yacc): http://www.gnu.org/software/bison/\r\n\r\nReferences\r\n============\r\n\r\n- `Immensely helpful`_\r\n- `Just as useful`_\r\n- `One of my questions`_\r\n- `Implementation of Lua (PDF)`_\r\n- `Interpreter implementation options`_\r\n- `Python's Innards`_\r\n\r\n.. _Immensely helpful: http://stackoverflow.com/a/2644949\r\n.. _Just as useful: http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/\r\n.. _One of my questions: http://stackoverflow.com/q/13094001/1689220\r\n.. _Implementation of Lua (PDF): www.lua.org/doc/jucs05.pdf\r\n.. _Interpreter implementation options: http://realityforge.org/code/virtual-machines/2011/05/19/interpreters.html\r\n.. _Python's Innards: http://tech.blog.aknin.name/2010/04/02/pythons-innards-introduction/\r\n\r\nTODO (version 0.2)\r\n===================\r\n\r\n- Implement interactive mode (like Python's '>>>')\r\n- Serialize bytecode/symbols/constants (like Python's .pyc files)\r\n- Finalize syntax\r\n- Implement bytecode compiler\r\n\r\n  - Determine/iteratively improve instruction set\r\n  - Append instructions faster (currently function call for each)\r\n  - Backpatch instructions faster (currently function call for each)\r\n  - Cleanly store loop state for backpatching ``BREAK`` and ``CONTINUE``\r\n  - Implement efficient symbol table (hash)\r\n  - Implement useful constant table\r\n  - Design function prototypes\r\n  - Bytecode optimizations\r\n\r\n- Implement bytecode interpreter (VM)\r\n\r\n  - Efficient object stack\r\n  - Fast instruction dispatch (gcc ``computed goto`` vs. ``switch-case``)\r\n  - Proper function call/return handling (call stack)\r\n\r\n- Implement a memory manager optimized for allocating many small blocks\r\n\r\n  This is more for the learning experience... I know it's difficult to\r\n  out-perform the GNU libc malloc implementation\r\n\r\n- Possibly implement an API for creating libraries\r\n\r\nCompleted in version 0.1\r\n=========================\r\n\r\nThe following features were completed in Luci v0.1.\r\nLuci v0.1 simply walked the abstract syntax tree and,\r\nfor each node, executed analogous expressions in C, i.e.\r\nfor each ``if-else`` node, a C function in the AST walking\r\ncode would recursively evaluate the conditional expression,\r\nthen if it was \"true\", evaluate the ``if-statements`` node,\r\notherwise it would evaluate the ``else-statements`` node.\r\n\r\nThis version is now obsolete, as the implementation\r\nwas inefficient and did not allow for nested control flow\r\nstatements, i.e. ``break``, ``continue``, ``return``.\r\n\r\n#. Implement all unary/binary operations offered by the C++ standard\r\n   (with proper operator precedence for each)\r\n#. Implement Integer, Double, and String types\r\n#. Implement a While loop construct\r\n#. Implement error recover (made a single exit point `die()`), which has global\r\n   access to the root ASTNode and root ExecEnviron\r\n#. Implement if/else conditional blocks. Decided against 'else if', which simplifies parser.\r\n#. Implement multi-parameter functions\r\n#. Implement a FILE * luci type, with open(), close(), read(), write() functions\r\n#. Create list types (syntax/parse), rename 'parameter' AST nodes since they're lists\r\n#. Implement For loops\r\n#. Re-work allocation/deallocation of LuciObjects to incorporate\r\n   reference counts.\r\n#. Rewrite list implementation to use dynamic array of pointers (rather than singly-linked\r\n   list. The singly-linked list was far less convenient since I'm using lists to implement\r\n   function parameters.\r\n#. Implement user-defined functions (barely)\r\n#. Track line numbers in abstract syntax tree for more helpful Runtime Error messages.\r\n\r\nSyntax Ideas\r\n=============\r\n\r\n-  function definitions::\r\n\r\n      identifier(param1, param2, etc.) {\r\n\r\n      }\r\n\r\n      identifier(arg1, arg2, etc)\r\n\r\n-  conditional blocks::\r\n\r\n      if (condition) {\r\n\r\n      } else {\r\n\r\n      }\r\n\r\n-  list range::\r\n\r\n      0..9, 0..42..3    (ruby)\r\n\r\n   or::\r\n\r\n      range(10), range(0, 42, 3)    (python)\r\n\r\n-  some kind of block comments, not just single line ``#...`` comments\r\n\r\n"}